from fastapi import FastAPI, APIRouter, HTTPException, Depends, Response
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional
import uuid
from datetime import datetime, timezone, timedelta
from passlib.context import CryptContext
from jose import JWTError, jwt
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import io


ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Security
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()
SECRET_KEY = os.environ.get("SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 days

# Create the main app without a prefix
app = FastAPI()

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")


# ============= MODELS =============
class User(BaseModel):
    model_config = ConfigDict(extra="ignore")
    
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    username: str
    full_name: str
    hashed_password: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class UserCreate(BaseModel):
    username: str
    password: str
    full_name: str


class UserLogin(BaseModel):
    username: str
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str
    user: dict


class LaboratoryReport(BaseModel):
    model_config = ConfigDict(extra="ignore")
    
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nama_petugas: str
    lab_fisika: str
    lab_biologi: str
    lab_kemurnian_genetik: str
    lab_nematoda: str
    lab_virus: str
    lab_bakteri: str
    lab_cendawan: str
    tanggal_pelaksanaan: str  # Format: YYYY-MM-DD
    user_id: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class LaboratoryReportCreate(BaseModel):
    nama_petugas: str
    lab_fisika: str
    lab_biologi: str
    lab_kemurnian_genetik: str
    lab_nematoda: str
    lab_virus: str
    lab_bakteri: str
    lab_cendawan: str
    tanggal_pelaksanaan: str


class LaboratoryReportUpdate(BaseModel):
    nama_petugas: Optional[str] = None
    lab_fisika: Optional[str] = None
    lab_biologi: Optional[str] = None
    lab_kemurnian_genetik: Optional[str] = None
    lab_nematoda: Optional[str] = None
    lab_virus: Optional[str] = None
    lab_bakteri: Optional[str] = None
    lab_cendawan: Optional[str] = None
    tanggal_pelaksanaan: Optional[str] = None


# ============= HELPER FUNCTIONS =============
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    
    user = await db.users.find_one({"id": user_id}, {"_id": 0})
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user


def generate_word_document(report: dict, lab_name: str, lab_content: str) -> io.BytesIO:
    """Generate Word document for a specific laboratory"""
    doc = Document()
    
    # Set margins
    sections = doc.sections
    for section in sections:
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)
    
    # Header
    header = doc.add_paragraph()
    header.alignment = WD_ALIGN_PARAGRAPH.CENTER
    run = header.add_run("Laporan Penyiap Bahan Uji dan Media Laboratorium\nBALAI BESAR PPMBTPH")
    run.bold = True
    run.font.size = Pt(14)
    
    doc.add_paragraph()  # Space
    
    # Laboratory info
    tanggal = datetime.fromisoformat(report['tanggal_pelaksanaan'])
    bulan = tanggal.strftime("%B")
    tahun = tanggal.strftime("%Y")
    
    lab_info = doc.add_paragraph()
    lab_info.add_run(f"Laboratorium\t\t: {lab_name}\n")
    lab_info.add_run(f"Bulan\t\t\t: {bulan}\n")
    lab_info.add_run(f"Tahun\t\t\t: {tahun}")
    
    doc.add_paragraph()  # Space
    
    # Table
    table = doc.add_table(rows=1, cols=6)
    table.style = 'Table Grid'
    
    # Header row
    hdr_cells = table.rows[0].cells
    headers = ['No', 'Jenis Kegiatan Penyiapan Bahan Uji dan Media', 'Nama Petugas', 'Tanggal', 'Keterangan', 'Paraf']
    for i, header_text in enumerate(headers):
        cell = hdr_cells[i]
        cell.text = header_text
        for paragraph in cell.paragraphs:
            for run in paragraph.runs:
                run.font.bold = True
                run.font.size = Pt(10)
        cell.paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Data row
    row_cells = table.add_row().cells
    row_cells[0].text = '1'
    row_cells[1].text = lab_content if lab_content else '-'
    row_cells[2].text = report['nama_petugas']
    row_cells[3].text = tanggal.strftime("%d/%m/%Y")
    row_cells[4].text = ''
    row_cells[5].text = ''
    
    # Add empty rows (as per template)
    for i in range(2, 8):
        row_cells = table.add_row().cells
        row_cells[0].text = str(i)
    
    doc.add_paragraph()  # Space
    doc.add_paragraph()  # Space
    
    # Footer signature
    footer_para = doc.add_paragraph()
    footer_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT
    footer_para.add_run(f"Depok, {tanggal.strftime('%d %B %Y')}\n")
    footer_para.add_run("Mengetahui,\n")
    footer_para.add_run("Penyelia Laboratorium\n\n\n\n")
    footer_para.add_run("_______________________\n")
    footer_para.add_run("Nama\n")
    footer_para.add_run("NIP")
    
    # Save to BytesIO
    file_stream = io.BytesIO()
    doc.save(file_stream)
    file_stream.seek(0)
    
    return file_stream


# ============= AUTH ROUTES =============
@api_router.post("/auth/register", response_model=Token)
async def register(user_data: UserCreate):
    # Check if username exists
    existing_user = await db.users.find_one({"username": user_data.username}, {"_id": 0})
    if existing_user:
        raise HTTPException(status_code=400, detail="Username already exists")
    
    # Create user
    hashed_password = get_password_hash(user_data.password)
    user = User(
        username=user_data.username,
        full_name=user_data.full_name,
        hashed_password=hashed_password
    )
    
    user_dict = user.model_dump()
    user_dict['created_at'] = user_dict['created_at'].isoformat()
    
    await db.users.insert_one(user_dict)
    
    # Create token
    access_token = create_access_token(data={"sub": user.id})
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        user={
            "id": user.id,
            "username": user.username,
            "full_name": user.full_name
        }
    )


@api_router.post("/auth/login", response_model=Token)
async def login(credentials: UserLogin):
    user = await db.users.find_one({"username": credentials.username}, {"_id": 0})
    
    if not user or not verify_password(credentials.password, user['hashed_password']):
        raise HTTPException(status_code=401, detail="Incorrect username or password")
    
    access_token = create_access_token(data={"sub": user['id']})
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        user={
            "id": user['id'],
            "username": user['username'],
            "full_name": user['full_name']
        }
    )


@api_router.get("/auth/me")
async def get_me(current_user: dict = Depends(get_current_user)):
    return {
        "id": current_user['id'],
        "username": current_user['username'],
        "full_name": current_user['full_name']
    }


# ============= LAPORAN ROUTES =============
@api_router.post("/laporan", response_model=LaboratoryReport)
async def create_report(report_data: LaboratoryReportCreate, current_user: dict = Depends(get_current_user)):
    report = LaboratoryReport(**report_data.model_dump(), user_id=current_user['id'])
    
    report_dict = report.model_dump()
    report_dict['created_at'] = report_dict['created_at'].isoformat()
    report_dict['updated_at'] = report_dict['updated_at'].isoformat()
    
    await db.laboratory_reports.insert_one(report_dict)
    
    return report


@api_router.get("/laporan", response_model=List[LaboratoryReport])
async def get_reports(
    tanggal: Optional[str] = None,
    bulan: Optional[str] = None,
    tahun: Optional[str] = None,
    current_user: dict = Depends(get_current_user)
):
    query = {"user_id": current_user['id']}
    
    if tanggal:
        query["tanggal_pelaksanaan"] = tanggal
    elif bulan and tahun:
        # Filter by month and year
        query["tanggal_pelaksanaan"] = {
            "$regex": f"^{tahun}-{bulan.zfill(2)}"
        }
    elif tahun:
        query["tanggal_pelaksanaan"] = {
            "$regex": f"^{tahun}"
        }
    
    reports = await db.laboratory_reports.find(query, {"_id": 0}).sort("tanggal_pelaksanaan", -1).to_list(1000)
    
    # Convert ISO strings back to datetime
    for report in reports:
        if isinstance(report['created_at'], str):
            report['created_at'] = datetime.fromisoformat(report['created_at'])
        if isinstance(report['updated_at'], str):
            report['updated_at'] = datetime.fromisoformat(report['updated_at'])
    
    return reports


@api_router.get("/laporan/{report_id}", response_model=LaboratoryReport)
async def get_report(report_id: str, current_user: dict = Depends(get_current_user)):
    report = await db.laboratory_reports.find_one({"id": report_id, "user_id": current_user['id']}, {"_id": 0})
    
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    
    # Convert ISO strings back to datetime
    if isinstance(report['created_at'], str):
        report['created_at'] = datetime.fromisoformat(report['created_at'])
    if isinstance(report['updated_at'], str):
        report['updated_at'] = datetime.fromisoformat(report['updated_at'])
    
    return report


@api_router.put("/laporan/{report_id}", response_model=LaboratoryReport)
async def update_report(
    report_id: str,
    report_data: LaboratoryReportUpdate,
    current_user: dict = Depends(get_current_user)
):
    # Check if report exists
    existing_report = await db.laboratory_reports.find_one({"id": report_id, "user_id": current_user['id']}, {"_id": 0})
    
    if not existing_report:
        raise HTTPException(status_code=404, detail="Report not found")
    
    # Update only provided fields
    update_data = {k: v for k, v in report_data.model_dump().items() if v is not None}
    update_data['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    await db.laboratory_reports.update_one(
        {"id": report_id, "user_id": current_user['id']},
        {"$set": update_data}
    )
    
    # Get updated report
    updated_report = await db.laboratory_reports.find_one({"id": report_id}, {"_id": 0})
    
    # Convert ISO strings back to datetime
    if isinstance(updated_report['created_at'], str):
        updated_report['created_at'] = datetime.fromisoformat(updated_report['created_at'])
    if isinstance(updated_report['updated_at'], str):
        updated_report['updated_at'] = datetime.fromisoformat(updated_report['updated_at'])
    
    return updated_report


@api_router.delete("/laporan/{report_id}")
async def delete_report(report_id: str, current_user: dict = Depends(get_current_user)):
    result = await db.laboratory_reports.delete_one({"id": report_id, "user_id": current_user['id']})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Report not found")
    
    return {"message": "Report deleted successfully"}


@api_router.get("/laporan/{report_id}/download/{lab_name}")
async def download_report(
    report_id: str,
    lab_name: str,
    current_user: dict = Depends(get_current_user)
):
    # Get report
    report = await db.laboratory_reports.find_one({"id": report_id, "user_id": current_user['id']}, {"_id": 0})
    
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    
    # Map lab_name to field and display name
    lab_mapping = {
        "fisika": ("lab_fisika", "Laboratorium Fisika"),
        "biologi": ("lab_biologi", "Laboratorium Biologi"),
        "kemurnian-genetik": ("lab_kemurnian_genetik", "Laboratorium Kemurnian Genetik"),
        "nematoda": ("lab_nematoda", "Laboratorium Nematoda"),
        "virus": ("lab_virus", "Laboratorium Virus"),
        "bakteri": ("lab_bakteri", "Laboratorium Bakteri"),
        "cendawan": ("lab_cendawan", "Laboratorium Cendawan")
    }
    
    if lab_name not in lab_mapping:
        raise HTTPException(status_code=400, detail="Invalid laboratory name")
    
    field_name, display_name = lab_mapping[lab_name]
    lab_content = report.get(field_name, "")
    
    if not lab_content:
        raise HTTPException(status_code=400, detail=f"No data for {display_name}")
    
    # Generate document
    doc_stream = generate_word_document(report, display_name, lab_content)
    
    # Return as download
    filename = f"Laporan_{display_name.replace(' ', '_')}_{report['tanggal_pelaksanaan']}.docx"
    
    return Response(
        content=doc_stream.getvalue(),
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )


@api_router.get("/laporan/rekap/{bulan}/{tahun}")
async def get_monthly_recap(
    bulan: str,
    tahun: str,
    current_user: dict = Depends(get_current_user)
):
    """Get monthly recap of all reports"""
    query = {
        "user_id": current_user['id'],
        "tanggal_pelaksanaan": {
            "$regex": f"^{tahun}-{bulan.zfill(2)}"
        }
    }
    
    reports = await db.laboratory_reports.find(query, {"_id": 0}).sort("tanggal_pelaksanaan", 1).to_list(1000)
    
    # Group by laboratory
    recap = {
        "bulan": bulan,
        "tahun": tahun,
        "total_laporan": len(reports),
        "per_laboratorium": {
            "Fisika": [],
            "Biologi": [],
            "Kemurnian Genetik": [],
            "Nematoda": [],
            "Virus": [],
            "Bakteri": [],
            "Cendawan": []
        }
    }
    
    for report in reports:
        if report.get('lab_fisika'):
            recap["per_laboratorium"]["Fisika"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_fisika'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_biologi'):
            recap["per_laboratorium"]["Biologi"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_biologi'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_kemurnian_genetik'):
            recap["per_laboratorium"]["Kemurnian Genetik"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_kemurnian_genetik'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_nematoda'):
            recap["per_laboratorium"]["Nematoda"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_nematoda'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_virus'):
            recap["per_laboratorium"]["Virus"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_virus'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_bakteri'):
            recap["per_laboratorium"]["Bakteri"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_bakteri'],
                "petugas": report['nama_petugas']
            })
        if report.get('lab_cendawan'):
            recap["per_laboratorium"]["Cendawan"].append({
                "tanggal": report['tanggal_pelaksanaan'],
                "kegiatan": report['lab_cendawan'],
                "petugas": report['nama_petugas']
            })
    
    return recap


# Health check
@api_router.get("/")
async def root():
    return {"message": "Laboratory Report API"}


# Include the router in the main app
app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
